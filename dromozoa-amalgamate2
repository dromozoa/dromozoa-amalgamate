#! /usr/bin/env lua

-- Copyright (C) 2015 Tomoyuki Fujimori <moyu@dromozoa.com>
--
-- This file is part of dromozoa-amalgamate.
--
-- dromozoa-amalgamate is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- dromozoa-amalgamate is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with dromozoa-amalgamate.  If not, see <http://www.gnu.org/licenses/>.

local package_loaded = {}

for k, v in pairs(package.loaded) do
  package_loaded[k] = v
end

local loadstring = require "dromozoa.commons.loadstring"
local read_file = require "dromozoa.commons.read_file"
local searchpath = require "dromozoa.commons.searchpath"
local sequence = require "dromozoa.commons.sequence"
local unpack = require "dromozoa.commons.unpack"

for k, v in pairs(package.loaded) do
  package.loaded[k] = package_loaded[k]
end

local searchers
if _VERSION >= "Lua 5.2" then
  searchers = package.searchers
else
  searchers = package.loaders
end

local function copy(this, that)
  for k, v in pairs(that) do
    this[k] = v
  end
  return this
end

local function remove_hashbang(script)
  return (script:gsub("^%#%![^\n]*\n", ""))
end

local context = {
  arg = copy({}, arg);
  searchers = copy({}, searchers);
  require = require;
  exit = os.exit;
}

local script
local commands, output = (function ()
  local commands = sequence()
  local output

  arg[-1] = "lua"
  arg[0] = nil

  local i = 1
  local n = #arg
  while i <= n do
    local a, b = arg[i], arg[i + 1]
    local c = a:match("^%-(.*)")
    if c == nil then
      break
    else
      if c == "e" then
        commands:push(function ()
          return pcall(assert(loadstring(b)))
        end)
        i = i + 2
      elseif c == "l" then
        commands:push(function ()
          return pcall(require, b)
        end)
        i = i + 2
      elseif c == "-" then
        i = i + 1
        break
      elseif c == "" then
        commands:push(function ()
          script = remove_hashbang(io.read("*a"))
          return pcall(assert(loadstring(script)), unpack(arg))
        end)
        arg[0] = "-"
        i = i + 1
        break
      elseif c == "o" then
        output = b
        i = i + 2
      else
        error("unrecognized option '" .. a .. "'")
      end
    end
  end

  if arg[0] == nil then
    local a = arg[i]
    if a ~= nil then
      commands:push(function ()
        local handle = assert(io.open(a))
        script = remove_hashbang(handle:read("*a"))
        handle:close()
        return pcall(assert(loadstring(script)), unpack(arg))
      end)
      arg[0] = a
      i = i + 1
    end
  end

  local j = 0
  for i = i, n do
    j = j + 1
    arg[j] = arg[i]
  end
  for i = j + 1, n do
    arg[i] = nil
  end

  return commands, output
end)()

local stack = sequence():push({
  require = sequence();
  loader = sequence();
})

local function searcher(modname, loader, filename, ...)
  if type(loader) == "function" then
    stack:top().loader:push({
      modname = modname;
      filename = filename;
    })
  end
  return loader, filename, ...
end

for k, v in pairs(searchers) do
  searchers[k] = function (modname, ...)
    return searcher(modname, v(modname, ...))
  end
end

require = function (modname)
  local this = {
    modname = modname;
    require = sequence();
    loader = sequence();
  }
  stack:top().require:push(this)
  stack:push(this)
  local result = context.require(modname)
  stack:pop()
  return result
end

local exit_success = function () end
local exit_failure = "EXIT_FAILURE"

os.exit = function (code)
  if code == nil or code == 0 then
    error(exit_success)
  else
    error(exit_failure)
  end
end

for command in commands:each() do
  local result, message = command()
  if not result and message ~= exit_success then
    error(message)
  end
end

copy(arg, context.arg)
copy(searchers, context.searchers)
require = context.require
os.exit = context.exit

local out
if output == nil then
  out = io.stdout
else
  out = assert(io.open(output, "wb"))
end

local function amalgamate(this)
  for v in this.require:each() do
    amalgamate(v)
  end
  for v in this.loader:each() do
    local modname = v.modname
    local filename = v.filename
    if filename == nil then
      filename = searchpath(modname, package.path)
    end
    if filename ~= nil and filename:find("%.lua$") then
      out:write("dromozoa_amalgamate_loaded = true\n")
      out:write(("package.loaded[%q] = (function ()\n"):format(modname))
      out:write(remove_hashbang(read_file(filename)))
      out:write("end)()\n")
    end
  end
end

if script == nil then
  amalgamate(stack:top())
else
  out:write("#! /usr/bin/env lua\n")
  amalgamate(stack:top())
  out:write(script)
end

if output ~= nil then
  out:close()
end
